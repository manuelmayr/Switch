{"name":"Switch","body":"Switch - A Query Language for Ruby\r\n==================================\r\n\r\n**Switch** is a deep embedding of relational Queries into Ruby. With **Switch**\r\nthere is no syntactic or stylistic difference between Ruby programs that operate\r\nover in-memory array objects or database-resident tables, even if these programs\r\nrely on array order or nesting. **Switch**'s buil-in compiler and SQL code generator guarantee to emit few queries, addressing long-standing performance problems that trace back to **Rails' ActiveRecord** database binding.\r\n\r\n> Looks like Ruby, but performs like handcrafted SQL\r\n\r\nis the ideal that drives the research and development behind **Switch**.\r\n\r\n\r\nInstallation\r\n------------\r\n\r\n### Setting up Pathfinder\r\nThe relational algebra plans provided by **Switch** are usually too unwiedly to be handled directly by database systems. We rely thus on [Pathfinder](http://db.inf.uni-tuebingen.de/research/pathfinder/download) to optimize the plans in\r\norder to get efficient SQL-Code.\r\n\r\nOn Mac OSX a proper [brew](http://mxcl.github.com/homebrew/) formula should be available soon:\r\n\r\n```\r\nbrew install pathfinder\r\n```\r\n\r\nFor other platforms download the **Pathfinder** source tarball [here](http://db.inf.uni-tuebingen.de/files/research/pathfinder/download/pathfinder-0.41.tar.gz).\r\n\r\n\r\n### Download Switch\r\nGet a clone of **Switch**\r\n\r\n```\r\ngit clone git@github.com:manuelmayr/Switch.git\r\n```\r\n\r\nand run `rake package` in the **Switch** directory.\r\n\r\nA simple\r\n\r\n```\r\ngem install ./pkg/switch-0.0.1.gem\r\n```\r\ncompletes the installation and takes care of dependencies.\r\n\r\n\r\nUsing Switch\r\n------------\r\nUse the following snippet as IRB initialization file\r\n```\r\n$ irb -f irb_init.rb\r\n```\r\nto play aroung with **Switch**.\r\n\r\n**Switch** uses **ActiveRecord** merely as an infrastructure to interact with different database systems. **ActiveRecord** is thus *not involved* in the translation scheme we are using. \r\n\r\n\r\n```\r\n# filename: irb_init.rb\r\nrequire \"switch\"\r\nrequire \"logger\"\r\n\r\ninclude Switch\r\nQueryable.engine = Engine.new ActiveRecord::Base\r\n\r\nActiveRecord::Base.logger = Logger.new(\"/tmp/switch.log\")\r\nActiveRecord::Base.logger.level = Logger::DEBUG\r\nActiveRecord::Base.logger.datetime_format = \"%Y-%m-%d %H:%M:%S\"\r\n\r\nActiveRecord::Base.configurations = { \r\n  'pg' => {\r\n     :username => '<username>',\r\n     :password => '<password>',\r\n     :adapter  => :postgresql,\r\n     :encoding => 'utf8',\r\n     :database => '<database>'\r\n   },  \r\n   'db2' => {\r\n     :username => '<username>',\r\n     :password => '<password>',\r\n     :adapter  => :ibm_db,\r\n     :encoding => 'utf8',\r\n     :database => '<database>'\r\n   },  \r\n}\r\n\r\n\r\nActiveRecord::Base.establish_connection 'db2'  # for DB2 or pg for postgres\r\n```\r\n\r\n The queries generated by **Switch** are dumped to `/tmp/switch.log`.\r\n\r\n\r\nExamples\r\n--------\r\n\r\nThe `to_sql` trigger method is used to display the associated SQL-Code of a Query. Use the `each` trigger method to execute a query on a database and marshal the \r\nresult back to **Ruby** objects.\r\n\r\n**Executing a query on a database:**\r\n\r\n```\r\n# Articles is a table in a database automatically recognized by Switch as such\r\nArticles.select { |id, name, price| price >= 42 }.each do |a|\r\n  puts \"#{a[:name]} => #{a[:price]}\"\r\nend\r\n```\r\n\r\n### Literals\r\n\r\nThe rather tedious constructor ``Atom`` is only used when we use a literal\r\nas source object to a query.  \r\n**Switch** is able to cope with\r\n\r\n1. numeric literals\r\n2. strings\r\n3. arbitrary nested lists\r\n4. records\r\n\r\n**Numeric Literals and Strings**\r\n\r\n```\r\nAtom(42).to_sql\r\nAtom(3.14).to_sql\r\nAtom(\"Hello World!\").to_sql\r\n```\r\n\r\n**Arbitrary Nested Lists**\r\n\r\n```\r\nAtom([1,2,3]).to_sql\r\nAtom([ [1,2], [3,4] ]).to_sql \r\nAtom([ [1,2], 3 ]).to_sql     # Attention: This is not possible\r\n\r\n# more complicated stuff\r\nAtom([[1,2,3],[4,5,6]]).flatten.take(4).drop(3).to_sql # => [4]\r\nAtom([[[1,2,3],[4,5,6]]]).nth(1).nth(2).take(2).drop(1).to_sql # => [5] \r\n```\r\n\r\n**Records**\r\n\r\n```\r\nAtom({ a:10, b:42 }).to_sql\r\nAtom({ a:{ b:10, c:42 }, d:[12,67], e:\"34\" }).to_sql\r\n```\r\n\r\n### Table Access\r\n\r\nTables in a database are automatically recognized by **Switch**. Supposed\r\nyou have a table ``Articles`` in your database, accessing it via **Switch**\r\nis really smooth.\r\n\r\n```\r\nArticles.to_sql\r\n```\r\n**Switch** checks if there is really an `Articles` table in your database and\r\nprovides a queryable object. Each table is simply a list of record. In case\r\nof `Articles` it would e.g. be the following (`[{ id:1, name:\"IPhone 4S\", price:629.00 }, { id:2, name:\"Macbook Air 13\", price:1249.00}, ...]`)\r\n\r\n```\r\n# getting the name of each article\r\nArticles.map { |a| a.name }.take(5).to_sql\r\n# or\r\nArticles.map { |id,name,price| name }.take(5).sql\r\n\r\n# adding 42 to the price of each product\r\n# that is cheaper than 23 bucks\r\nArticles.select { |a| a.price < 23 }.\r\n         map { |a| \r\n                   { id:a.id,\r\n                     name:a.name,\r\n                     price:a.price + 42 } }.\r\n         to_sql\r\n```\r\n\r\n### Use Ruby Syntax\r\n\r\n```\r\nAtom([[1,2,3],[3]]).map(&:length).to_sql # => [3,1]\r\n\r\n```\r\n\r\n### Query Combinators aka Methods\r\n\r\nThe examples above are just a small subset of what you can accomplish with **Switch**. **Switch** supports the following methods you can use in your queries:\r\n\r\n```\r\nmap select group_by sort_by partition uniq flatten flat_map zip all? any?\r\nnone? empty? one? member? append reverse take drop take_while drop_while\r\nat first last length avg sum max min max_by min_by\r\n```\r\n\r\n## Additional \r\n\r\nThe `to_sql` method accepts a file or a string to write to  \r\n`to_sql(\"foo.sql\")` or `to_sql(File.open(\"foo.sql\", \"w\"))`.  \r\nUsually it writes to STDOUT.\r\n\r\nReferences\r\n----------\r\n* [A Deep Embedding of Queries into Ruby](http://db.inf.uni-tuebingen.de/publications/)  \r\n  Torsten Grust, Manuel Mayr.  \r\n  In Proceedings of the 28th IEEE International Conference on Data Engineering (ICDE 2012), Washington, DC, USA, April 2012.\r\n","tagline":"Database Query Language for Ruby","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}